---
title: CSAPP第三章
date: 2026.2.17
comments: true
---

## 程序的机器级表示

### gcc的编译

- 预处理   ```gcc -E```   处理#开头的预编译指令
- 编译   ```gcc -S```   将源码编译为汇编代码
- 汇编   ```gcc -c```   将汇编代码编译为二进制代码
- 链接   ```gcc```   组合二进制生成可执行文件

```main.c``` ->```main.i``` -> ```main.s``` -> ```main.o``` -> ```main```



## 寄存器的本质

x87_64有16个通用寄存器（每个都是8byte）（64bit

- %rax：8byte（64bit
- %eax：rax的低32位

原16位机器， 有8个16bit的寄存器

32位机器， 有8个32bit

## 寄存器

| %rax | retun value - caller saved |
| ---- | -------------------------- |
| %rdi | argument #1 - caller saved |
| %rsi | argument #2 - caller saved |
| %rdx | argument #3 - caller saved |
| #rcx | argument #4 - caller saved |
| %r8  | argument #5 - caller saved |
| %r9  | argument #6 - caller saved |
| %r10 | caller saved               |
| %r11 | caller saved               |
| %rsp | stack pointer              |
| %rbx | callee saved               |
| %rbp | callee saved               |
| %r12 | callee saved               |
| %r13 | callee saved               |
| %r14 | callee saved               |
| %r15 | callee saved               |

- caller saved  调用者保存，在调用其他函数的函数内部，将需要的值进行保存，调用完其他函数后再释放。
  - %r10, %r11
  - %rax
  - %rdi, %rsi, %rdx, %rcx, %r8, %r9
- callee saved  被调用者保存，在被调用函数内部，将接下来可能改变的值进行保存，最后再释放。
  - %rbx, %rbp, %r12, %r13, %r14, %r15 

## 汇编代码

### 操作数

- Immediate（立即数）：$8
- Register（寄存器）：%rsx
- Memory Reference（内存引用）： （%rdi）

####  addr=Imm+R[rb]+R[ri]⋅s=Imm(rb, ri, s)

#### 数组 `a[i]`

- `rb = &a[0]`
- `ri = i`
- `s = sizeof(a[0])`
- `Imm = 0`

地址：`&a[i] = rb + ri*s`

#### 结构体字段 `p->y`（y 在偏移 8）

- `rb = p`
- `Imm = 8`
- 不需要 index

地址：`&p->y = rb + 8`

#### 局部变量（在栈上）

- `rb = rbp` 或 `rsp`（栈基准）
- `Imm` 为负偏移（如 `-16`）
- 通常不需要 index

### 操作码

- movq（move quad word = 8 byte） - movl（move double word） - movw（move word = 2 byte） - movb（move byte）
  - MOV指令，无法从内存移动到内存（即 源操作数和目的操作数不可以同时为内存
  - movzbw  ->  零拓展，从byte拓展为word
  - movsbw  ->  符号拓展，从byte拓展为word
- addq 
- subq
- xorq
- ret

#### Stack

栈本质上就是一块内存空间，生长方向是从高地址到低地址（和堆相反

- pushq %rax  --->  把寄存器%rax的数据放到栈里（内存）
- popq %rbx  

#### LEAQ

leaq S, D  --> Load Effective Address (加载有效地址)

- ```leaq Imm(rb, ri, s), rax ``` 等价于  ``` rax = Imm + R[rb] + R[ri]*s ```
- 



