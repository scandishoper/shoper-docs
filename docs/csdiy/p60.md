---
title: CS106L / assignment2笔记
date: 2026.2.21
comments: true
---

## CS106L / assignment2笔记

### 1) `cerr` 该“返回什么”？

- `std::cerr` 只是输出错误信息，不“返回值”。
- 函数返回类型不是 `void` 时，**所有分支都必须 return**：
  - 打不开文件：常见做法 `return {};`（返回空 set）
  - 或者 `throw std::runtime_error(...)`（强制调用者处理）

------

### 2) `ifstream` vs `istringstream`

- `std::ifstream`：从**文件**读（可能失败：文件打不开，`if (!in)` 有意义）
- `std::istringstream`：从**字符串**读（常用于把一行/名字按空格分词）
  - 刚构造一般不会失败，所以 `if (!in)` 通常没意义
  - 读失败用 `while (iss >> word)` 判断即可

------

### 3) `mch.str(stu)` 是什么？为什么要 `clear()`？

- `stringstream::str(x)`：把流内部的“缓冲字符串”替换成 `x`
- 复用同一个 `istringstream` 时：
  - 上一次读到 EOF 后会留下 `eofbit/failbit`
  - 下次即使 `str()` 换内容也可能读不出来
  - 所以要：`mch.clear(); mch.str(stu);`
- 更稳：每次循环新建 `std::istringstream iss(stu);` 避免状态坑

------

### 4) `queue<const string*>` 存指针 vs 存字符串

- 存指针的动机：
  - 避免拷贝、节省内存/时间
  - 引用原集合里的字符串
- 风险：**生命周期问题**
  - 原集合 `students` 一旦销毁 → 指针变悬空（dangling）→ 解引用是 UB（可能崩溃/乱码）
- `set` 的生命周期结束：
  - 局部变量：离开 `{}` 作用域就销毁
  - `main` 里的局部变量：`main` 结束销毁
  - `static` / 全局：程序结束销毁

------

### 5) `const std::string* best` 的 `const` 含义

- `const std::string* best`：不能通过 `best` 修改字符串内容，但**可以改变 best 指向谁**
- 对比：
  - `std::string* const p`：指针本身不能变，但内容可变
  - `const std::string* const p`：指针和内容都不能变

------

### 7) “跳过空指针”意义？

- 在你的作业里，队列里 push 的通常是 `&stu`，理论上不会是 `nullptr`
- `if (p == nullptr) continue;` 更多是防御性写法
- 真正危险的是“悬空指针”，它通常不是 nullptr，这句防不了

------

### 8) 你写的 `f(name)` 有啥问题？

- `istringstream` 需要 `#include <sstream>`

------

## 9) 段错误怎么找：推荐流程

### 编译时加调试信息 + Sanitizer

```
g++ -std=c++20 -g -O0 -Wall -Wextra -fsanitize=address,undefined main.cpp -o main
./main
```

- ASan/UBSan 会直接告诉你：错误类型 + 你代码的行号

### 用 gdb 看栈

- `run`：运行
- `bt`：看崩溃调用栈（最重要）
- `frame 0`：切到崩溃帧
- `list`：看崩溃行附近代码
- `print 变量`：看指针/容器内容

------

## 10) 你这次 ASan 报告怎么读出来的结论

- 报错：`stack-use-after-return`
  - 含义：**函数返回后还在用它栈上的局部变量地址**
- 报告点名：
  - 崩溃触发在 `get_match`（你在比较/取 size 时解引用了坏指针）
  - 坏指针来自 `find_matches` 的局部变量 `student`
- 典型原因：在 `find_matches` 里把“局部变量 student 的地址”push 进队列，函数返回后指针悬空