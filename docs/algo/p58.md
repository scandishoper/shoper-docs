---
title: 线性基
date: 2026.2.17
comments: true
---

# 线性基（XOR Linear Basis）笔记

## 1. 核心直觉：异或 = GF(2) 线性代数

把一个整数看成二进制向量（每一位是 0/1）。
在 GF(2)（模 2）下：

- 加法：逐位 mod 2
- 对应到整数操作：**异或 ⊕**

所以：

- “若干数异或起来” = “若干向量的线性组合”
- 能否异或出目标值 = 目标是否在这些向量的线性张成（span）中

竞赛里说的“异或线性基”就是：在 GF(2) 下做高斯消元，保留一组线性无关的“主元向量”。

------

## 2. 线性基维护什么结构？

对每个 bit 位 `b`（从高到低），维护：

- `base[b]`：一个数，且它的**最高位 1**恰好在 `b`（主元在 b）
- 这样所有 `base[b]` 互相线性无关，并张成所有插入向量的 span

不变量（重要）：

1. 若 `base[b] != 0`，则 `base[b]` 的最高位为 b
2. 对任意数 x，若能被表示，则从高位到低位用 `base` 消元可消到 0

------

## 3. 插入（insert）的原理与伪代码

给一个数 `x`，从最高位往下：

- 如果 x 在第 b 位是 1：
  - 若 `base[b]` 为空：把 x 放进去当新的主元，结束
  - 否则：`x ^= base[b]` 消掉这一位（最高位下降）

```cpp
for b from MAXBIT downto 0:
  if x has bit b:
    if base[b] == 0:
      base[b] = x
      return
    else:
      x ^= base[b]
```

为什么正确：这就是 GF(2) 的高斯消元。
x 被不断用已有主元消掉最高位；若最终变成 0，说明它线性相关；否则某个新最高位成为新主元。

复杂度：O(MAXBIT)（通常 31 或 61）。

------

## 4. 判定（canRepresent）：能否异或出目标

同样从高位往下消元：

- 目标 x 若某位 b 为 1：
  - 如果 `base[b]` 不存在 → 不可表示
  - 否则 `x ^= base[b]` 继续消
- 最终能消成 0 → 可表示

```cpp
bool canRepresent(long long x){
  for b from MAXBIT downto 0:
    if x has bit b:
      if base[b]==0 return false
      x ^= base[b]
  return true
}
```

------

## 5. 构造（getRepresentation）：如何找出“选了哪些数”

### 5.1 为什么构造不止需要 `pos[b]`

很多人初写会只记一个 `pos[b]` 表示 `base[b]` 来自哪个输入元素，但这不够：
因为 `base[b]` 往往是**多个输入数异或后**形成的主元，不是单个元素。

所以需要给每个 `base[b]` 额外维护它的“来源表达式”。

### 5.2 两种常见表示法

**A. 稀疏表示：vector 下标集合（对称差 merge）**

- `repr[b]` 存一个升序无重复的下标列表
- 合并表示法 = 对称差（出现两次抵消）

**B. 小维度 bitmask（推荐技巧）**
观察：线性基的维度 ≤ MAXBIT+1（31 或 61），所以真正“主元个数”最多 61。
我们只要给“每个主元”编号 0..cnt-1，用 `unsigned long long` 的 bitmask 表示表达式即可。

- `msk[b]`：`base[b]` 的表达式 bitmask
- 插入消元时同步 `curMask ^= msk[b]`
- 查询消元时同步 `pick ^= msk[b]`
- 最终 pick 的每一位映射回对应主元来源下标

这就是你后面那份“没有 merge 但能构造”的写法本质。

------

## 6. 经典题型：从 a[i]/b[i] 选 c[i] 使 xor 为 0

题意回顾：
给 a、b 长度 n，选 `c[i]=a[i]` 或 `b[i]`，使 `c1⊕…⊕cn=0`

### 6.1 关键变形（一定要背）

先全选 a：

- `A = a1 ⊕ a2 ⊕ ... ⊕ an`

定义差分：

- `d[i] = a[i] ⊕ b[i]`

如果把第 i 位从 a 改成 b，相当于总异或再 ⊕ 上 `d[i]`。
设改动集合为 S，则最终总异或：

- `A ⊕ (⊕_{i∈S} d[i])`

要求它为 0：

- `A ⊕ (⊕_{i∈S} d[i]) = 0`
- 等价于
  **⊕_{i∈S} d[i] = A**

所以问题变成：

> 是否能从 d[i] 中选一批异或出 A？并构造 S。

这就是线性基的标准 “subset xor / span 判定与构造”。

### 6.2 用线性基解

1. 计算 `A = xor_all(a[i])`
2. 对每个 i 计算 `d[i]=a[i]^b[i]`
3. 把所有 `d[i]` 插入线性基（带表示法）
4. 用线性基表示 `A`
   - 若不可表示：输出 -1
   - 若可表示得到集合 S：
     - i∈S → 选 b[i]
     - i∉S → 选 a[i]

------

## 7. 代码易错点清单（来自我们对话里踩过的坑）

1. 只记录 `pos[b]` 无法构造：

- base[b] 可能由多个输入异或得到

1. 表示目标时必须同步消元：

- 不能只“看到 bit=1 就选 base[b]”，还要 `x ^= base[b]`

1. 位数范围要对齐数据范围：

- int 范围 → 30/31 位
- long long 范围 → 60/61 位

------

## 8. 一句话记忆法

- **线性基 = GF(2) 的高斯消元**
- **判定**：目标能否消成 0
- **构造**：消元同时维护“表达式”，表达式用对称差（或 bitmask XOR）

```c++
#include <bits/stdc++.h>
using namespace std;

// XOR basis with reconstruction (64-bit values, <= 61 pivots so 64-bit mask works)
struct B {
    static const int K = 60;            // 0..60 (enough for <= 1e18)
    long long b[K+1]{};                 // basis vectors
    unsigned long long m[K+1]{};        // mask of chosen pivots
    int id[64]{};                       // pivot index -> original id
    int c = 0;                          // pivot count

    void ins(long long x, int i) {      // insert value x with original id i
        if (!x) return;
        unsigned long long s = 1ULL << c;
        for (int k = K; k >= 0; --k) if ((x >> k) & 1LL) {
            if (!b[k]) { b[k] = x; m[k] = s; id[c++] = i; return; }
            x ^= b[k];
            s ^= m[k];
        }
    }

    bool rep(long long x, unsigned long long &s) { // represent x, return mask s
        s = 0;
        for (int k = K; k >= 0; --k) if ((x >> k) & 1LL) {
            if (!b[k]) return false;
            x ^= b[k];
            s ^= m[k];
        }
        return true;
    }
};

// Example usage for your original problem:
// Choose c[i]=a[i] or b[i] s.t. xor(c)=0, else print -1.
int main() {
    ios::sync_with_stdio(false);
    cin.tie(nullptr);

    int T; 
    cin >> T;
    while (T--) {
        int n; cin >> n;
        vector<long long> a(n+1), b(n+1);
        long long x = 0;
        for (int i = 1; i <= n; ++i) { cin >> a[i]; x ^= a[i]; }
        for (int i = 1; i <= n; ++i) cin >> b[i];

        B z;
        for (int i = 1; i <= n; ++i) z.ins(a[i] ^ b[i], i);

        unsigned long long s;
        if (!z.rep(x, s)) { cout << -1 << "\n"; continue; }

        vector<char> u(n+1, 0);
        for (int k = 0; k < z.c; ++k) if ((s >> k) & 1ULL) u[z.id[k]] ^= 1;

        for (int i = 1; i <= n; ++i)
            cout << (u[i] ? b[i] : a[i]) << (i == n ? '\n' : ' ');
    }
    return 0;
}

```

