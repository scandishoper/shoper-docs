---
title: 二叉树的遍历
date: 2025.2.23
cover: assets/2cb79efe667b08d4b12e3b103d67653.jpg
swiper_index: 10
top_group_index: 10
background: "#fff"
updated:
tags: 传统算法
categories: 算法
keywords:
description:
top:
top_img:
comments:
toc:
toc_number:
toc_style_simple:
copyright:
copyright_author:
copyright_author_href:
copyright_url:
copyright_info:
mathjax:
katex:
aplayer:
highlight_shrink:
aside:
ai:
---

### [题目](https://ac.nowcoder.com/acm/contest/21763/D)

```c++
#include <iostream>
#include <queue>
using namespace std;
struct ty
{
    int z, y;
}a[500005];
int vis[500005];
void xian(int f)
{
    cout << f << ' ';
    if (a[f].z) xian(a[f].z);
    if (a[f].y) xian(a[f].y);
    return ;
}
void zhong (int f)
{
    if (a[f].z) zhong(a[f].z);
    cout << f << ' ';
    if (a[f].y) zhong(a[f].y);
    return ;
}
void hou(int f)
{
    if (a[f].z) hou(a[f].z);
    if (a[f].y) hou(a[f].y);
    cout << f << ' ';
    return ;
}
void ceng(int f)
{
    queue<int> q;
    q.push(f);
    while (q.size())
    {
        int y = q.front();
        q.pop();
        cout << y << ' ';
        if (a[y].z) q.push(a[y].z);
        if (a[y].y) q.push(a[y].y);
    }
    return ;
}
int main()
{
    int n;
    cin >> n;
    int f = 0;
    for (int i = 1; i < n; i++)
    {
        int u, v, op;
        cin >> u >> v >> op;
        vis[u] = 1;
        if (op == 0) a[v].z = u;
        else a[v].y = u;
    }
    for (int i = 1; i < n; i++)
        if (vis[i] == 0) f = i;
    xian(f);
    cout << endl;
    zhong(f);
    cout << endl;
    hou(f);
    cout << endl;
    ceng(f);
    return 0;
}
```
