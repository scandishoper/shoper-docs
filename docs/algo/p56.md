---
title: ST表
date: 2026.2.17
comments: true
---

# ST 表（Sparse Table）学习笔记 + 模板

## 一、算法简介

**ST 表（Sparse Table）** 是一种用于处理**区间最值查询（RMQ）**的高效数据结构。
 核心思想：

> 通过预处理所有长度为 2^k 的区间的最值，在查询时利用区间的二进制分割快速合并结果。

### 适用范围

- 操作是 **幂等的（idempotent）**（即 `f(x, x) = x`，例如 `min/max/gcd`）
- 区间查询多，**无修改操作**（静态 RMQ）
- 时间复杂度：
  - 预处理：`O(n log n)`
  - 查询：`O(1)`



## 二、核心思想

假设我们要支持：

> 查询区间 `[L, R]` 的最小值（或最大值）

定义：

```cpp
st[i][k] = 区间 [i, i + 2^k - 1] 的最小值
```

状态转移：

```c++
st[i][k] = min(st[i][k-1], st[i + (1 << (k-1))][k-1]);
```

> 查询时：
>
> > 区间 `[L, R]` 长度 = `len = R - L + 1`
> > 找到 `k = floor(log2(len))`
> > 则区间最小值：
>
> ```c++
> ans = min(st[L][k], st[R - (1 << k) + 1][k]);
> ```

## 三、代码模板（支持 RMQ 最大值查询）

```c++
#include<bits/stdc++.h>
#define int long long
using namespace std;
using ll = long long;
using pii = pair<int, int>;
using pdd = pair<double, double>;
const int N = (int)2e5 + 9;
const int M = (int)1e5 + 9;
const int mod = (int)1e9 + 7;
const ll INF = LLONG_MAX;

void solve() {
    int n, m;
    cin >> n >> m;
    vector<int> lg(n + 5);
    lg[1] = 0;
    for (int i = 2; i <= n; i++) lg[i] = lg[i >> 1] + 1;
    vector<vector<int>> f(n + 5, vector<int>(lg[n] + 5));
    for (int i = 1; i <= n; i++) {
        cin >> f[i][0];
    }
    for (int j = 1; j <= lg[n]; j++) {
        for (int i = 1; i + (1 << j) - 1 <= n; i++) {
            f[i][j] = max(f[i][j - 1], f[i + (1 << (j - 1))][j - 1]);
        }
    }
    while (m--) {
        int l, r;
        cin >> l >> r;
        int k = lg[r - l + 1];
        cout << max(f[l][k], f[r - (1 << k) + 1][k]) << "\n";
    }

}

signed main()
{
    ios::sync_with_stdio(false);
    cin.tie(0);
    int _ = 1;
    //cin >> _;
    while(_--) {
        solve();
    }
    return 0;
}
```

## 五、扩展应用

| 功能         | 修改点                                |
| ------------ | ------------------------------------- |
| 区间最大值   | 将 `min` 改为 `max`                   |
| 区间 GCD     | 将 `min` 改为 `gcd`                   |
| 区间最值下标 | 同时维护下标数组                      |
| 二维 ST 表   | 常用于稠密矩阵（`O(nm log n log m)`） |

## 六、常见错误点

1. **下标越界**：`st[i + (1 << k) - 1]` 要确保不超过 n。
2. **log 数组未预处理**：`lg2_` 必须在 `build_st()` 前计算好。
3. **1-based 与 0-based 混用**：比赛中建议全部使用 1-based。
4. **修改操作无效**：ST 表是静态结构，不能修改数组。